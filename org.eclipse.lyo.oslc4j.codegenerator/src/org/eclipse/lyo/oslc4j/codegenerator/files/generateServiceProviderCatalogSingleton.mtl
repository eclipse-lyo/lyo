[comment encoding = UTF-8 /]
[comment
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *     Michael Fiedler      - adapted for Bugzilla service provider
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *     Matthieu Helleboid   - initialize each service provider separately
 *     Anass Radouani       - initialize each service provider separately
 *******************************************************************************/
/]

[module generateServiceProviderCatalogSingleton('http://org.eclipse.lyo/oslc4j/adaptorInterface')]

[import org::eclipse::lyo::oslc4j::codegenerator::services::services/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::serviceProviderCatalogServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::adaptorInterfaceServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::serviceProviderServices/]

[template public generateServiceProviderCatalogSingleton(aServiceProviderCatalog : ServiceProviderCatalog)]
[file (javaClassFullFileNameForSingleton(aServiceProviderCatalog), false, 'UTF-8')]
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *     Michael Fiedler      - adapted for Bugzilla service provider
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *     Matthieu Helleboid   - initialize each service provider separately
 *     Anass Radouani       - initialize each service provider separately
 *
 * This file is generated by org.eclipse.lyo.oslc4j.codegenerator
 *******************************************************************************/

package [javaClassPackageNameForSingleton(aServiceProviderCatalog) /];

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.core.UriBuilder;

import org.eclipse.lyo.oslc4j.client.ServiceProviderRegistryURIs;
import org.eclipse.lyo.oslc4j.core.model.Publisher;
import org.eclipse.lyo.oslc4j.core.model.Service;
import org.eclipse.lyo.oslc4j.core.model.ServiceProvider;
import org.eclipse.lyo.oslc4j.core.model.ServiceProviderCatalog;
import org.eclipse.lyo.oslc4j.core.OSLC4JUtils;

import [javaClassFullNameForAdaptorManager(containingAdaptorInterface(aServiceProviderCatalog)) /];
[for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]
import [javaClassFullName(aServiceProvider) /];
[/for]

// [protected ('imports')]
// [/protected]

/**
 * This is the OSLC service provider catalog for the Bugzilla adapter.  Service providers are
 * not registered with the catalog until a request comes in to access either the catalog or a
 * specific service provider.   This request could be from an external consumer or an internal
 * request triggered by a consumer accessing a change request.
 *
 * The service providers are created and registered in the initServiceProvidersFromProducts()
 * method.  A list of accessible products is retrieved from Bugzilla and a ServiceProvider is
 * created and registered for each using the Bugzilla productId as the identifier.
 *
 * The registered service providers are refreshed on each catalog or service provider collection
 * request.
 */
public class [javaClassNameForSingleton(aServiceProviderCatalog) /]
{
    private static final ServiceProviderCatalog             serviceProviderCatalog;
    [comment TODO: We here assume that 1 single serviceProvider type is specified in the SPCatalog.
    In the metamodel, a SPCatalog  can have 1+ serviceProvider types.
    For example, one SP type maps to the products. Another SP type maps to "something-else".
    In this case, each such SP type would need to define its name. (for example "ProductServiceProvider")
    In this case, loop through the SP types, and create a variable for each. You will also need to loop through and create the functions below for each such SP type.
    Alternatively, define serviceProviders as some Dictionary, where the key is the SP name, and the value is the SortedMap below/]
    private static final SortedMap<String, ServiceProvider> serviceProviders = new TreeMap<String, ServiceProvider>();

    static
    {
        serviceProviderCatalog = new ServiceProviderCatalog();
        URI catalogUri = UriBuilder.fromUri(OSLC4JUtils.getServletURI()).path("/catalog/singleton").build();
        serviceProviderCatalog.setAbout(catalogUri);
        serviceProviderCatalog.setTitle("[aServiceProviderCatalog.title /]");
        serviceProviderCatalog.setDescription("[aServiceProviderCatalog.description /]");
        [if (not aServiceProviderCatalog.publisher.oclIsUndefined())]
        serviceProviderCatalog.setPublisher(new Publisher("[aServiceProviderCatalog.publisher.title /]", "[aServiceProviderCatalog.publisher.identifier /]"));
        serviceProviderCatalog.getPublisher().setIcon(new URI("[aServiceProviderCatalog.publisher.icon /]"));
        [/if]
    }

    private [javaClassNameForSingleton(aServiceProviderCatalog) /]()
    {
        super();
    }


    public static URI getUri()
    {
        return serviceProviderCatalog.getAbout();
    }

    public static ServiceProviderCatalog getServiceProviderCatalog(HttpServletRequest httpServletRequest)
    {
        initServiceProviders(httpServletRequest);
        return serviceProviderCatalog;
    }

    public static ServiceProvider [ '[' ']' /] getServiceProviders(HttpServletRequest httpServletRequest)
    {
        synchronized(serviceProviders)
        {
            initServiceProviders(httpServletRequest);
            return serviceProviders.values().toArray(new ServiceProvider[ '[' /] serviceProviders.size()[ ']' /]);
        }
    }

    [for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]

    private static URI construct[aServiceProvider.javaName(true)/]URI([aServiceProvider.instanceMethodSignature() /])
    {
        String basePath = OSLC4JUtils.getServletURI();
        Map<String, Object> pathParameters = new HashMap<String, Object>();
        [for (instanceCompositeID: String | aServiceProvider.instanceCompositeID()) separator(lineSeparator())]
        pathParameters.put("[instanceCompositeID /]", [instanceCompositeID /]);
        [/for]
        String instanceURI = "[aServiceProvider.instanceURI() /]";

        final UriBuilder builder = UriBuilder.fromUri(basePath);
        return builder.path(instanceURI).buildFromMap(pathParameters);
    }

    private static String [aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodSignature() /])
    {
        String identifier = [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator('+')]"/" + [instanceCompositeID /][/for];
        return identifier;
    }

    public static ServiceProvider get[aServiceProvider.javaName(true)/](HttpServletRequest httpServletRequest, [aServiceProvider.instanceMethodSignature() /])
    {
        ServiceProvider serviceProvider;

        synchronized(serviceProviders)
        {
            String identifier = [aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodParameterList() /]);
            serviceProvider = serviceProviders.get(identifier);

            //One retry refreshing the service providers
            if (serviceProvider == null)
            {
                getServiceProviders(httpServletRequest);
                serviceProvider = serviceProviders.get(identifier);
            }
        }

        if (serviceProvider != null)
        {
            return serviceProvider;
        }

        throw new WebApplicationException(Status.NOT_FOUND);
    }

    public static ServiceProvider register[aServiceProvider.javaName(true)/](final HttpServletRequest httpServletRequest,
                                                          final ServiceProvider serviceProvider,
                                                          [aServiceProvider.instanceMethodSignature() /])
                                                throws URISyntaxException
    {
        synchronized(serviceProviders)
        {
            final URI serviceProviderURI = construct[aServiceProvider.javaName(true)/]URI([aServiceProvider.instanceMethodParameterList() /]);
            return register[aServiceProvider.javaName(true)/]NoSync(serviceProviderURI,
                                                 serviceProvider,
                                                 [aServiceProvider.instanceMethodParameterList() /]);
        }
    }

    /**
    * Register a service provider with the OSLC catalog
    *
    * @param serviceProviderURI
    * @param serviceProvider
    * @param productId
    * @return
    */
    private static ServiceProvider register[aServiceProvider.javaName(true)/]NoSync(final URI serviceProviderURI,
                                                                 final ServiceProvider serviceProvider
                                                                 [commaSeparate(aServiceProvider.instanceMethodSignature(), true, false)/])
    {
        final SortedSet<URI> serviceProviderDomains = getServiceProviderDomains(serviceProvider);

        String identifier = [aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodParameterList()/]);
        serviceProvider.setAbout(serviceProviderURI);
        serviceProvider.setIdentifier(identifier);
        serviceProvider.setCreated(new Date());
        serviceProvider.setDetails(new URI[ '[' ']' /] {serviceProviderURI});

        serviceProviderCatalog.addServiceProvider(serviceProvider);
        serviceProviderCatalog.addDomains(serviceProviderDomains);

        serviceProviders.put(identifier, serviceProvider);

        return serviceProvider;
    }

    // This version is for self-registration and thus package-protected
    static ServiceProvider register[aServiceProvider.javaName(true)/](final ServiceProvider serviceProvider[commaSeparate(aServiceProvider.instanceMethodSignature(), true, false)/])
                                            throws URISyntaxException
    {
        synchronized(serviceProviders)
        {
            final URI serviceProviderURI = construct[aServiceProvider.javaName(true)/]URI([aServiceProvider.instanceMethodParameterList()/]);

            return register[aServiceProvider.javaName(true)/]NoSync(serviceProviderURI, serviceProvider[commaSeparate(aServiceProvider.instanceMethodParameterList(), true, false)/]);
        }
    }

    public static void deregister[aServiceProvider.javaName(true)/]([aServiceProvider.instanceMethodSignature()/])
    {
        synchronized(serviceProviders)
        {
            final ServiceProvider deregisteredServiceProvider = serviceProviders.remove([aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodParameterList()/]));

            if (deregisteredServiceProvider != null)
            {
                final SortedSet<URI> remainingDomains = new TreeSet<URI>();

                for (final ServiceProvider remainingServiceProvider : serviceProviders.values())
                {
                    remainingDomains.addAll(getServiceProviderDomains(remainingServiceProvider));
                }

                final SortedSet<URI> removedServiceProviderDomains = getServiceProviderDomains(deregisteredServiceProvider);

                removedServiceProviderDomains.removeAll(remainingDomains);
                serviceProviderCatalog.removeDomains(removedServiceProviderDomains);
                serviceProviderCatalog.removeServiceProvider(deregisteredServiceProvider);
            }
            else
            {
                throw new WebApplicationException(Status.NOT_FOUND);
            }
        }
    }
    [/for]

    private static SortedSet<URI> getServiceProviderDomains(final ServiceProvider serviceProvider)
    {
        final SortedSet<URI> domains = new TreeSet<URI>();

        if (serviceProvider!=null) {
            final Service [ '[' ']' /] services = serviceProvider.getServices();
            for (final Service service : services)
            {
                final URI domain = service.getDomain();

                domains.add(domain);
            }
        }
        return domains;
    }

    /**
     * Retrieve a list of products from Bugzilla and construct a service provider for each.
     *
     * Each product ID is added to the parameter map which will be used during service provider
     * creation to create unique URI paths for each Bugzilla product.  See @Path definition at
     * the top of BugzillaChangeRequestService.
     *
     * @param httpServletRequest
     */
    protected static void initServiceProviders (HttpServletRequest httpServletRequest)
    {
        try {
            // [protected ('initServiceProviders')]
            // [/protected]

            String basePath = OSLC4JUtils.getServletURI();
            [for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]

            [javaClassName(aServiceProvider) /] [ '[' ']' /] [javaClassName(aServiceProvider).toLowerFirst()/]s = [javaClassNameForAdaptorManager(containingAdaptorInterface(aServiceProviderCatalog)) /].get[aServiceProvider.javaClassName()/]s(httpServletRequest);
            //Register each service provider
            for ([javaClassName(aServiceProvider) /] serviceProviderInfo : [javaClassName(aServiceProvider).toLowerFirst()/]s) {
                String identifier = [aServiceProvider.javaName(false)/]Identifier([for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(', ')]serviceProviderInfo.[instanceCompositeID /][/for]);
                if (! serviceProviders.containsKey(identifier)) {
                    String serviceProviderName = serviceProviderInfo.name;
                    String title = "[aServiceProvider.title.concat(': ') /]" + serviceProviderName + "(" + identifier + ")";
                    String description = "[aServiceProvider.description.concat(': ') /]" + serviceProviderName + "(" + identifier + ")";
                    [if (aServiceProvider.publisher.oclIsUndefined())]
                    Publisher publisher = null;
                    [else]
                    Publisher publisher = new Publisher("[aServiceProvider.publisher.title /]", "[aServiceProvider.publisher.identifier /]");
                    [/if]
                    Map<String, Object> parameterMap = new HashMap<String, Object>();
                    [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(lineSeparator())]
                    parameterMap.put("[instanceCompositeID /]", serviceProviderInfo.[instanceCompositeID /]);
                    [/for]
                    final ServiceProvider aServiceProvider = [javaClassNameForFactory(aServiceProvider) /].createServiceProvider(basePath, title, description, publisher, parameterMap);
                    register[aServiceProvider.javaName(true)/](aServiceProvider, [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(', ')]serviceProviderInfo.[instanceCompositeID /][/for]);
                }
            }
            [/for]
        } catch (Exception e) {
            e.printStackTrace();
            throw new WebApplicationException(e,Status.INTERNAL_SERVER_ERROR);
        }
    }
}

[/file]
[/template]
