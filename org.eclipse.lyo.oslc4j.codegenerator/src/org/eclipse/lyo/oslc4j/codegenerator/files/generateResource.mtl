[comment encoding = UTF-8 /]
[comment
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *  
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *	   Sam Padgett	       - initial API and implementation
 *     Michael Fiedler     - adapted for OSLC4J
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *******************************************************************************/
/]

[module generateResource('http://org.eclipse.lyo/oslc4j/adaptorInterface')]

[import org::eclipse::lyo::oslc4j::codegenerator::services::services/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::resourceServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::resourcePropertyServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::adaptorInterfaceServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::domainSpecificationServices/]

[template public generateResource(aResource : Resource, anAdaptorInterface : AdaptorInterface)]
[file (javaClassFullFileName(aResource, anAdaptorInterface), false, 'UTF-8')]
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *  
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *	   Sam Padgett	       - initial API and implementation
 *     Michael Fiedler     - adapted for OSLC4J
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *
 * This file is generated by org.eclipse.lyo.oslc4j.codegenerator
 *******************************************************************************/


package [javaClassPackageName(aResource, anAdaptorInterface) /];

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.text.SimpleDateFormat;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.Iterator;
import javax.servlet.http.HttpServletRequest;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import javax.ws.rs.core.UriBuilder;

import org.eclipse.lyo.oslc4j.core.annotation.OslcAllowedValue;
import org.eclipse.lyo.oslc4j.core.annotation.OslcDescription;
import org.eclipse.lyo.oslc4j.core.annotation.OslcName;
import org.eclipse.lyo.oslc4j.core.annotation.OslcNamespace;
import org.eclipse.lyo.oslc4j.core.annotation.OslcOccurs;
import org.eclipse.lyo.oslc4j.core.annotation.OslcPropertyDefinition;
import org.eclipse.lyo.oslc4j.core.annotation.OslcRange;
import org.eclipse.lyo.oslc4j.core.annotation.OslcReadOnly;
import org.eclipse.lyo.oslc4j.core.annotation.OslcRepresentation;
import org.eclipse.lyo.oslc4j.core.annotation.OslcResourceShape;
import org.eclipse.lyo.oslc4j.core.annotation.OslcTitle;
import org.eclipse.lyo.oslc4j.core.annotation.OslcValueType;
import org.eclipse.lyo.oslc4j.core.model.AbstractResource;
import org.eclipse.lyo.oslc4j.core.model.Link;
import org.eclipse.lyo.oslc4j.core.model.Occurs;
import org.eclipse.lyo.oslc4j.core.model.OslcConstants;
import org.eclipse.lyo.oslc4j.core.model.Representation;
import org.eclipse.lyo.oslc4j.core.model.ValueType;

import [javaClassFullNameForAdaptorServletListener(anAdaptorInterface) /]; 
import [javaInterfaceFullNameForAdaptorConstants(anAdaptorInterface) /];
[for (aProperty: ResourceProperty | allProperties(aResource)->sortedBy(name))]
[if(Sequence{'Resource', 'LocalResource'}->includes(aProperty.valueType.toString())) ]
[if (not aProperty.range.oclIsUndefined())]
import [javaClassFullName(aProperty.range, anAdaptorInterface) /];	
[/if]
[/if]
[/for]

// [protected ('imports')]
// [/protected]

@OslcNamespace([javaInterfaceNameForAdaptorConstants(anAdaptorInterface) /].[domainSpecificationNamespaceConstantName(aResource.definingDomainSpecification()) /])
@OslcName([javaInterfaceNameForAdaptorConstants(anAdaptorInterface) /].[resourceConstantName(aResource) /]) 
@OslcResourceShape(title = "[aResource.name /] Resource Shape", describes = [javaInterfaceNameForAdaptorConstants(anAdaptorInterface) /].[resourceTypeConstantName(aResource) /])
public class [javaClassName(aResource) /]
	extends [if (aResource.directParentResource().oclIsUndefined())]AbstractResource[else][javaClassName(aResource.directParentResource()) /][/if]
	implements [for (aResourceToInterface: Resource | OrderedSet{aResource}->union(aResource.interfaceResources())) separator(', ')][javaInterfaceName(aResourceToInterface) /][/for]
{

[for (aProperty: ResourceProperty | ((aResource.resourceProperties->asSequence())->union(interfaceProperties(aResource))))]
private [javaAttributeTypeDeclaration(aProperty) /] [javaAttributeName(aProperty, aResource)/][if javaAttributeTypeNeedsConstruction(aProperty)] = new [javaAttributeTypeDeclaration(aProperty)/]()[/if];  
[/for]

public [javaClassName(aResource) /]()
       throws URISyntaxException
{
    super();

	// [protected ('constructor1')]
	// [/protected]
}

public [javaClassName(aResource) /](final URI about)
       throws URISyntaxException
{
    super(about);

	// [protected ('constructor2')]
	// [/protected]
}

public [javaClassName(aResource) /]([commaSeparate(aResource.instanceMethodSignature(anAdaptorInterface), false, false)/])
       throws URISyntaxException
{
	this (constructURI([commaSeparate(aResource.instanceMethodParameterList(anAdaptorInterface), false, false)/]));
	// [protected ('constructor3')]
	// [/protected]
}

public static URI constructURI([commaSeparate(aResource.instanceMethodSignature(anAdaptorInterface), false, false)/])
{
    String basePath = [javaClassNameForAdaptorServletListener(anAdaptorInterface) /].getServicesBase();
    Map<String, Object> pathParameters = new HashMap<String, Object>();
    [for (instanceCompositeID: String | aResource.instanceCompositeID(anAdaptorInterface)) separator(lineSeparator())]
    pathParameters.put("[instanceCompositeID /]", [instanceCompositeID /]);
    [/for]
    String instanceURI = "[aResource.instanceURI(anAdaptorInterface) /]";
  
    final UriBuilder builder = UriBuilder.fromUri(basePath);
    return builder.path(instanceURI).buildFromMap(pathParameters);
}

public static Link constructLink([commaSeparate(aResource.instanceMethodSignature(anAdaptorInterface), false, true)/] final String label)
{
	return new Link(constructURI([commaSeparate(aResource.instanceMethodParameterList(anAdaptorInterface), false, false)/]), label);
}

public static Link constructLink([commaSeparate(aResource.instanceMethodSignature(anAdaptorInterface), false, false)/])
{
	return new Link(constructURI([commaSeparate(aResource.instanceMethodParameterList(anAdaptorInterface), false, false)/]));
}

public String toString()
{
	return toString(false);
}

public String toString(boolean asLocalResource)
{
		String result = "";
		// [protected ('toString_init')]
		// [/protected]

		if (asLocalResource) {
			result = result + "{a Local [aResource.name.toUpperFirst() /] Resource} - update [aResource.name.toUpperFirst() /].toString() to present resource as desired.";
			// [protected ('toString_bodyForLocalResource')]
			// [/protected]
		}
		else {
			result = getAbout().toString();
		}

		// [protected ('toString_finalize')]
		// [/protected]

		return result;
}

public String toHtml()
{
	return toHtml(false);
}

public String toHtml(boolean asLocalResource)
{
		String result = "";
		// [protected ('toHtml_init')]
		// [/protected]

		if (asLocalResource) {
			result = toString(true);
			// [protected ('toHtml_bodyForLocalResource')]
			// [/protected]
		}
		else {
			result = "<a href=\"" + getAbout() + "\">" + toString() + "</a>";
		}

		// [protected ('toHtml_finalize')]
		// [/protected]

		return result;
}

[for (aProperty: ResourceProperty | ((aResource.resourceProperties->asSequence())->union(interfaceProperties(aResource))))]
	[if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
    public void add[aProperty.name.toUpperFirst() /](final [javaAttributeBaseType(aProperty) /] [aProperty.name /] )
    {
        this.[javaAttributeName(aProperty, aResource) /].add([aProperty.name /]);
    }
	[/if]
[/for]

[for (aProperty: ResourceProperty | ((aResource.resourceProperties->asSequence())->union(interfaceProperties(aResource))))]
   	[nameAnnotation(aProperty) /]
   	[propertyDefinitionAnnotation(aProperty, aResource, anAdaptorInterface) /]
	[descriptionAnnotation(aProperty) /]
	[occursAnnotation(aProperty) /]
	[valueTypeAnnotation(aProperty) /]
	[representationAnnotation(aProperty) /]
	[rangeAnnotation(aProperty, aResource, anAdaptorInterface) /]
	[readOnlyAnnotation(aProperty) /]
	[titleAnnotation(aProperty) /]
    public [javaAttributeTypeDeclaration(aProperty) /] [if (aProperty.valueType.toString() = 'Boolean')]is[else]get[/if][javaAttributeName(aProperty, aResource).toUpperFirst() /]()
    {
        return [javaAttributeName(aProperty, aResource) /];
    }

[/for]

[for (aProperty: ResourceProperty | ((aResource.resourceProperties->asSequence())->union(interfaceProperties(aResource))))]
    public void set[javaAttributeName(aProperty, aResource).toUpperFirst() /](final [javaAttributeTypeDeclaration(aProperty) /] [aProperty.name /] )
    {
	[if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
        this.[javaAttributeName(aProperty, aResource) /].clear();
        if ([aProperty.name /] != null)
        {
            this.[javaAttributeName(aProperty, aResource) /].addAll([aProperty.name /]);
        }

	[else]
        this.[javaAttributeName(aProperty, aResource) /] = [aProperty.name /];
	[/if]
    }
[/for]

[for (aProperty: ResourceProperty | ((aResource.resourceProperties->asSequence())->union(interfaceProperties(aResource))))]
    static public String [javaAttributeName(aProperty, aResource) /]ToHtmlForCreation (final HttpServletRequest httpServletRequest[commaSeparate(aResource.collectionMethodSignature(anAdaptorInterface), true, false)/])
    {
		String s = "";

		// [protected (javaAttributeName(aProperty, aResource).concat('asHtmlForCreation_init'))]
		// [/protected]

		s = s + "<label for=\"[aProperty.name/]\">[aProperty.name/]: </LABEL>";

		// [protected (javaAttributeName(aProperty, aResource).concat('asHtmlForCreation_mid'))]
		// [/protected]

		[let valueType : String = aProperty.valueType.toString()]
			[if (Sequence{'String', 'XMLLiteral', 'DateTime', 'URI', 'Double', 'Float', 'Integer'}->includes(valueType))]
				s= s + [resourcePropertyAsTextInputForCreation(aProperty) /];
			[elseif(valueType = 'Boolean')]
				s= s + "<input name=\"[aProperty.name/]\" type=\"radio\" value=\"true\">True<br><input name=\"[aProperty.name/]\" type=\"radio\" value=\"false\">False";
			[elseif(Sequence{'Resource', 'LocalResource'}->includes(valueType))]
					[comment TODO: How to deal with properties that are resources? Should then also be created, or should hte user get a list of existing such resources to choose from. 
					Latter sounds most reasonable. For now just ignore such properties./]
			[/if]
		[/let]

		// [protected (javaAttributeName(aProperty, aResource).concat('asHtmlForCreation_finalize'))]
		// [/protected]

		return s; 
    }
[/for]

[comment TODO: This ToHTML is quite complicated. At the moment, I get expections because some of the properties are null.
I am getting to many if/else-ses. I think I need to rethink calmely to have a cleaner structure. Good enough for now I hope. /]
[for (aProperty: ResourceProperty | ((aResource.resourceProperties->asSequence())->union(interfaceProperties(aResource))))]
    public String [javaAttributeName(aProperty, aResource) /]ToHtml()
    {
		String s = "";

		// [protected (javaAttributeName(aProperty, aResource).concat('toHtml_init'))]
		// [/protected]

		s = s + "<label for=\"[aProperty.name/]\"><strong>[aProperty.name/]</strong>: </LABEL>";

		// [protected (javaAttributeName(aProperty, aResource).concat('toHtml_mid'))]
		// [/protected]

		try {
		[comment For these basic valueTypes, one can simply call toString on the attribte /]
		[if (Sequence{'Boolean', 'String', 'XMLLiteral', 'DateTime', 'URI', 'Double', 'Float', 'Integer'}->includes(aProperty.valueType.toString()))]
		    [if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
		        s = s + "<ul>";
				Iterator<[javaAttributeBaseType(aProperty) /]> itr = [javaAttributeName(aProperty, aResource) /].iterator();
				while(itr.hasNext()) {
					s = s + "<li>";
					s= s + itr.next().toString();
					s = s + "</li>";
				}
		        s = s + "</ul>";
			[else]
				if ([javaAttributeName(aProperty, aResource)/] == null) {
					s= s + "<em>null</em>";				
				}
				else {
					s= s + [javaAttributeName(aProperty, aResource)/].toString();				
				}
		    [/if]
		[comment a property with valueType of resource or LocalResource can return either a Class directly referring to a Resource, or Link. 
		If we get a Link, we want to check if we can also work out which kind of resource class this Link refers to. If we can find out, 
		we want to call toHtml on that class. if we cannot, we simply print the Link as a string. /]
		[elseif(Sequence{'Resource', 'LocalResource'}->includes(aProperty.valueType.toString()))]
		    [if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
		        s = s + "<ul>";
				Iterator<[javaAttributeBaseType(aProperty) /]> itr = [javaAttributeName(aProperty, aResource) /].iterator();
				while(itr.hasNext()) {
					s = s + "<li>";
				    [if (javaAttributeBaseType(aProperty) = 'Link')]
					    [if (not aProperty.range.oclIsUndefined())]
							[comment Even if it is a Link, there are cases where I actually know that the link should point to a particular resource class.
							(For example, for valueType = Resource, we get a Link irrespective of whether the valueType is set to a specific resource or not. ) /]
							s = s + (new [javaClassName(aProperty.range) /] (itr.next().getValue())).toHtml([if (aProperty.valueType.toString() = 'LocalResource')]true[else]false[/if]);
						[else]
							[comment just print the Link's URI as a String /]
                            if (itr.next().getValue() == null) {
                                s= s + "<em>null</em>";             
                            }
                            else {
                                s = s + itr.next().getValue().toString();
                            }
					    [/if]
					[else]
						[comment itr refers to direct Resource class, and hence can simply call toHtml() on /]
						s = s + itr.next().toHtml([if (aProperty.valueType.toString() = 'LocalResource')]true[else]false[/if]);
				    [/if]
					s = s + "</li>";
				}
		        s = s + "</ul>";
			[else]
			    [if (javaAttributeBaseType(aProperty) = 'Link')]
				    [if (not aProperty.range.oclIsUndefined())]
						[comment Even if it is a Link, there are cases where I actually know that the link should point to a particular resource class.
						(For example, for valueType = Resource, we get a Link irrespective of whether the valueType is set to a specific resource or not. ) /]
						s = s + (new [javaClassName(aProperty.range) /] ([javaAttributeName(aProperty, aResource)/].getValue())).toHtml([if (aProperty.valueType.toString() = 'LocalResource')]true[else]false[/if]);
					[else]
						[comment just print the Link's URI as a String /]
                    if ([javaAttributeName(aProperty, aResource)/].getValue() == null) {
                        s = s + "<em>null</em>";             
                    }
                    else {
                        s = s + [javaAttributeName(aProperty, aResource)/].getValue().toString();                
                    }
				    [/if]

				[else]
					[comment the attribute refers to direct Resource class, and hence can simply call toHtml() on /]
					s = s + [javaAttributeName(aProperty, aResource)/].toHtml([if (aProperty.valueType.toString() = 'LocalResource')]true[else]false[/if]);
			    [/if]

		    [/if]
		[/if]
	    } catch (Exception e) {
	        e.printStackTrace();
	    }

		// [protected (javaAttributeName(aProperty, aResource).concat('toHtml_finalize'))]
		// [/protected]

		return s; 
    }
[/for]

}

[/file]
[/template]


[template public resourcePropertyAsTextInputForCreation(aProperty: ResourceProperty)]
"<input name=\"[aProperty.name/]\" type=\"text\" style=\"width: 400px\" id=\"[aProperty.name/]\" [if (Sequence{'excatlyOne', 'oneOrMany'}->includes(aProperty.occurs.toString()))]required[/if]>"
[/template]

